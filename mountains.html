<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mountain Terrain</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            width: 100%;
            height: 600vh;
            background: #f5f2eb;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        }

        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            display: block;
            background: #f5f2eb;
            z-index: 10;
        }

        /* Fixed Header Navigation */
        header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
            padding: 20px 40px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: transparent;
        }

        .logo {
            font-size: 18px;
            font-weight: 600;
            color: #f5f2eb;
            letter-spacing: 1px;
        }

        .logo::before {
            content: "▲ ";
            color: #f5f2eb;
        }

        nav {
            display: flex;
            gap: 40px;
            align-items: center;
        }

        nav a {
            text-decoration: none;
            color: #f5f2eb;
            font-size: 12px;
            font-weight: 500;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            transition: opacity 0.3s;
        }

        nav a:hover {
            opacity: 0.7;
        }

        .nav-right {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .watch-demo {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #f5f2eb;
            font-size: 11px;
            font-weight: 500;
            text-decoration: none;
            transition: opacity 0.3s;
        }

        .watch-demo:hover {
            opacity: 0.7;
        }

        .play-icon {
            width: 18px;
            height: 18px;
            background: #f5f2eb;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #1a1a1a;
            font-size: 8px;
        }

        .start-btn {
            background: #1a1a1a;
            color: #f5f2eb;
            padding: 8px 20px;
            border-radius: 25px;
            text-decoration: none;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: all 0.3s;
            border: none;
            cursor: pointer;
        }

        .start-btn:hover {
            transform: scale(1.05);
        }

        /* Hero Content - Moves with mountains in 3D space */
        .hero-content {
            position: fixed;
            top: 25%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 50;
            width: 100%;
            max-width: 900px;
            padding: 0 40px;
            opacity: 1;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .hero-content.fade-out {
            opacity: 0;
        }

        .trusted-by {
            font-size: 11px;
            color: #ffffff;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 20px;
            font-weight: 500;
        }

        .hero-content h1 {
            font-size: 42px;
            font-weight: 400;
            color: #ffffff;
            line-height: 1.3;
            margin-bottom: 25px;
            letter-spacing: -0.5px;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            transform: scale(1);
            transition: transform 0.1s ease;
        }

        .trusted-logos {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 60px;
            overflow: hidden;
            position: relative;
            height: 40px;
            transform: scale(1);
            transition: transform 0.1s ease;
        }

        .logos-container {
            display: flex;
            gap: 60px;
            animation: scroll-logos 20s linear infinite;
        }

        @keyframes scroll-logos {
            0% {
                transform: translateX(0);
            }
            100% {
                transform: translateX(-50%);
            }
        }

        .logo-item {
            font-size: 12px;
            color: #ffffff;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
            text-shadow: 0 1px 5px rgba(0, 0, 0, 0.3);
        }

        .logo-icon {
            width: 18px;
            height: 18px;
            background: #ffffff;
            border-radius: 2px;
        }

        /* Content Section */
        .content-section {
            position: fixed;
            top: 100vh;
            left: 0;
            width: 100%;
            height: 100vh;
            background: #f5f2eb;
            padding: 100px 40px;
            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 15;
            transition: transform 0.1s ease;
        }

        /* Cloud Shader Canvas */
        #cloudCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            display: block;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.1s ease;
        }

        #cloudCanvas.show {
            opacity: 1;
            pointer-events: auto;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <header id="header">
        <div class="logo">Adaline</div>
        <nav>
            <a href="#products">PRODUCTS</a>
            <a href="#pricing">PRICING</a>
            <a href="#blog">BLOG</a>
        </nav>
        <div class="nav-right">
            <a href="#" class="watch-demo">
                <span>WATCH DEMO</span>
                <div class="play-icon">▶</div>
            </a>
            <button class="start-btn">START FOR FREE</button>
        </div>
    </header>

    <div class="hero-content" id="heroContent">
        <h1>The single platform to iterate,<br>evaluate, deploy, and monitor AI agents</h1>
        <div class="trusted-by">TRUSTED BY</div>
        <div class="trusted-logos">
            <div class="logos-container">
                <div class="logo-item">
                    <div class="logo-icon"></div>
                    Discord
                </div>
                <div class="logo-item">
                    <div class="logo-icon"></div>
                    McKinsey & Company
                </div>
                <div class="logo-item">
                    <div class="logo-icon"></div>
                    DOORDASH
                </div>
                <div class="logo-item">
                    <div class="logo-icon"></div>
                    HubSpot
                </div>
                <!-- Duplicate for seamless loop -->
                <div class="logo-item">
                    <div class="logo-icon"></div>
                    Discord
                </div>
                <div class="logo-item">
                    <div class="logo-icon"></div>
                    McKinsey & Company
                </div>
                <div class="logo-item">
                    <div class="logo-icon"></div>
                    DOORDASH
                </div>
                <div class="logo-item">
                    <div class="logo-icon"></div>
                    HubSpot
                </div>
            </div>
        </div>
    </div>

    <div class="content-section">
        <h2>Explore More</h2>
        <p>Continue scrolling to discover more features and capabilities of our platform.</p>
    </div>

    <canvas id="cloudCanvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const vertexShader = `#version 300 es
        precision highp float;

        in vec2 position;
        out vec2 fragCoord;

        void main() {
            fragCoord = position * 0.5 + 0.5;
            gl_Position = vec4(position, 0.0, 1.0);
        }`;

        const fragmentShader = `#version 300 es
        precision highp float;

        uniform vec2 iResolution;
        uniform float iTime;
        uniform vec4 iMouse;
        uniform sampler2D iChannel0;
        uniform sampler2D iChannel1;
        uniform sampler2D iChannel2;
        uniform float scrollProgress;

        in vec2 fragCoord;
        out vec4 fragColor;

        #define SC (250.0)

        // Day/Night shader variables
        float fTurbulence = 0.35;
        vec3 vNightColor   = vec3(.15, 0.3, 0.6);
        vec3 vHorizonColor = vec3(0.6, 0.3, 0.4);
        vec3 vDayColor     = vec3(0.7,0.8,1);
        vec3 vSunColor     = vec3(1.0,0.8,0.6);
        vec3 vSunRimColor  = vec3(1.0,0.66,0.33);

        vec3 noised( in vec2 x ){
            vec2 p = floor(x);
            vec2 f = fract(x);
            vec2 u = f*f*(3.0-2.0*f);
            float a = texture(iChannel0,(p+vec2(0.5,0.5))/256.0,-100.0).x;
            float b = texture(iChannel0,(p+vec2(1.5,0.5))/256.0,-100.0).x;
            float c = texture(iChannel0,(p+vec2(0.5,1.5))/256.0,-100.0).x;
            float d = texture(iChannel0,(p+vec2(1.5,1.5))/256.0,-100.0).x;
            return vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));
        }

        const mat2 m2 = mat2(0.8,-0.6,0.6,0.8);

        float detailH( in vec2 x ){
            float d = 0.0;
            return d + 0.5*texture( iChannel2, x*2.0/SC, 0.0 ).x;
        }

        float detailM( in vec2 x ){
            float d = 0.0;
            return d;
        }

        float terrainH( in vec2 x ){
            vec2  p = x*0.003/SC;
            float a = 0.0;
            float b = 1.0;
            vec2  d = vec2(0.0);
            for( int i=0; i<15; i++ ){
                vec3 n = noised(p);
                d += n.yz;
                a += b*n.x/(1.0+dot(d,d));
                b *= 0.5;
                p = m2*p*2.0;
            }
            float de = detailH(x);
            return SC*100.0*a - de;
        }

        float terrainM( in vec2 x ){
            vec2  p = x*0.003/SC;
            float a = 0.0;
            float b = 1.0;
            vec2  d = vec2(0.0);
            for( int i=0; i<9; i++ ){
                vec3 n = noised(p);
                d += n.yz;
                a += b*n.x/(1.0+dot(d,d));
                b *= 0.5;
                p = m2*p*2.0;
            }
            return SC*100.0*a - detailH(x);
        }

        float terrainL( in vec2 x ){
            vec2  p = x*0.003/SC;
            float a = 0.0;
            float b = 1.0;
            vec2  d = vec2(0.0);
            for( int i=0; i<7; i++ ){
                vec3 n = noised(p);
                d += n.yz;
                a += b*n.x/(1.0+dot(d,d));
                b *= 0.5;
                p = m2*p*2.0;
            }
            return SC*100.0*a;
        }

        float interesct( in vec3 ro, in vec3 rd, in float tmin, in float tmax ){
            float t = tmin;
            for( int i=0; i<256; i++ ){
                vec3 pos = ro + t*rd;
                float h = pos.y - terrainM( pos.xz );
                if( h<(0.002*t) || t>tmax ) break;
                t += 0.5*h;
            }
            return t;
        }

        float softShadow(in vec3 ro, in vec3 rd ){
            float res = 1.0;
            float t = 0.001;
            for( int i=0; i<80; i++ ){
                vec3  p = ro + t*rd;
                float h = p.y - terrainM( p.xz );
                res = min( res, 16.0*h/t );
                t += h;
                if( res<0.001 ||p.y>(SC*200.0) ) break;
            }
            return clamp( res, 0.0, 1.0 );
        }

        vec3 calcNormal( in vec3 pos, float t ){
            vec2  eps = vec2( 0.002*t, 0.0 );
            return normalize( vec3( terrainH(pos.xz-eps.xy) - terrainH(pos.xz+eps.xy),2.0*eps.x,terrainH(pos.xz-eps.yx) - terrainH(pos.xz+eps.yx) ) );
        }

        vec3 camPath( float time ){
            return SC*1100.0*vec3( cos(0.0+0.23*time), 0.0, cos(1.5+0.21*time) );
        }

        float fbm( vec2 p ){
            float f = 0.0;
            f += 0.5000*texture( iChannel0, p/256.0 ).x; p = m2*p*2.02;
            f += 0.2500*texture( iChannel0, p/256.0 ).x; p = m2*p*2.03;
            f += 0.1250*texture( iChannel0, p/256.0 ).x; p = m2*p*2.01;
            f += 0.0625*texture( iChannel0, p/256.0 ).x;
            return f/0.9375;
        }

        mat3 setCamera( in vec3 ro, in vec3 ta, in float cr ){
            vec3 cw = normalize(ta-ro);
            vec3 cp = vec3(sin(cr), cos(cr),0.0);
            vec3 cu = normalize( cross(cw,cp) );
            vec3 cv = normalize( cross(cu,cw) );
            return mat3( cu, cv, cw );
        }

        vec3 renderSky( in vec3 rd, in float dayNightMix ){
            float fSunSpeed = dayNightMix * 3.14159;
            vec3 sundir = normalize( vec3(cos(fSunSpeed),sin(fSunSpeed),0.0) );
            float sun = clamp( dot(sundir,rd), 0.0, 1.0 );
            float fSunHeight = sundir.y;
            
            float fNightHeight = -0.8;
            float fDayHeight   = 0.3;
            float fHorizonLength = fDayHeight - fNightHeight;
            float fInverseHL = 1.0 / fHorizonLength;
            float fHalfHorizonLength = fHorizonLength / 2.0;
            float fInverseHHL = 1.0 / fHalfHorizonLength;
            float fMidPoint = fNightHeight + fHalfHorizonLength;
            
            float fNightContrib = clamp((fSunHeight - fMidPoint) * (-fInverseHHL), 0.0, 1.0);
            float fHorizonContrib = -clamp(abs((fSunHeight - fMidPoint) * (-fInverseHHL)), 0.0, 1.0) + 1.0;
            float fDayContrib = clamp((fSunHeight - fMidPoint) * ( fInverseHHL), 0.0, 1.0);
            
            vec3 vSkyColor = vec3(0.0);
            vSkyColor += mix(vec3(0.0),   vNightColor, fNightContrib);
            vSkyColor += mix(vec3(0.0), vHorizonColor, fHorizonContrib);
            vSkyColor += mix(vec3(0.0),     vDayColor, fDayContrib);
            
            vec3 col = vSkyColor;
            col -= clamp(rd.y, 0.0, 0.5);
            col += 0.4 * vSunRimColor * pow( sun,    4.0 );
            col += 1.0 * vSunColor    * pow( sun, 2000.0 );
            
            float fStarSpeed = -fSunSpeed * 0.5;
            float fStarContrib = clamp((fSunHeight - fDayHeight) * (-fInverseHL), 0.0, 1.0);
            vec3 vStarDir = rd * mat3( vec3(cos(fStarSpeed), -sin(fStarSpeed), 0.0),
                                       vec3(sin(fStarSpeed),  cos(fStarSpeed), 0.0),
                                       vec3(0.0,             0.0,            1.0));
            col += pow((texture(iChannel0, vStarDir.xy).r + texture(iChannel0, vStarDir.zy).r) * 0.5, 42.0) * fStarContrib * 40.0;
            
            return col;
        }

        vec3 render( in vec3 ro, in vec3 rd ){
            vec3 light1 = normalize( vec3(-0.8,0.4,-0.3) );
            float tmin = 1.0;
            float tmax = 1000.0*SC;
            float maxh = 300.0*SC;
            float tp = (maxh-ro.y)/rd.y;
            if( tp>0.0 ){
                if( ro.y>maxh ) tmin = max( tmin, tp );
                else            tmax = min( tmax, tp );
            }
            
            vec3 col;
            float t = interesct( ro, rd, tmin, tmax );
            
            // Day/Night transition based on scroll
            float dayNightMix = scrollProgress;
            
            if( t>tmax){
                col = renderSky( rd, dayNightMix );
            }else{
                vec3 pos = ro + t*rd;
                vec3 nor = calcNormal( pos, t );
                vec3 ref = reflect( rd, nor );
                float fre = clamp( 1.0+dot(rd,nor), 0.0, 1.0 );
                float r = texture( iChannel0, (7.0/SC)*pos.xz/256.0 ).x;
                col = (r*0.25+0.75)*0.9*mix( vec3(0.08,0.05,0.03), vec3(0.10,0.09,0.08), texture(iChannel0,0.00007*vec2(pos.x,pos.y*48.0)/SC).x );
                col = mix( col, 0.20*vec3(0.45,.30,0.15)*(0.50+0.50*r),smoothstep(0.70,0.9,nor.y) );
                col = mix( col, 0.15*vec3(0.30,.30,0.10)*(0.25+0.75*r),smoothstep(0.95,1.0,nor.y) );
                float h = smoothstep(55.0,80.0,pos.y/SC + 25.0*fbm(0.01*pos.xz/SC) );
                float e = smoothstep(1.0-0.5*h,1.0-0.1*h,nor.y);
                float o = 0.3 + 0.7*smoothstep(0.0,0.1,nor.x+h*h);
                float s = h*e*o;
                col = mix( col, 0.29*vec3(0.62,0.65,0.7), smoothstep( 0.1, 0.9, s ) );
                float amb = clamp(0.5+0.5*nor.y,0.0,1.0);
                float dif = clamp( dot( light1, nor ), 0.0, 1.0 );
                float bac = clamp( 0.2 + 0.8*dot( normalize( vec3(-light1.x, 0.0, light1.z ) ), nor ), 0.0, 1.0 );
                float sh = 1.0; if( dif>=0.0001 ) sh = softShadow(pos+light1*20.0,light1);
                vec3 lin  = vec3(0.0);
                lin += dif*vec3(7.00,5.00,3.00)*vec3( sh, sh*sh*0.5+0.5*sh, sh*sh*0.8+0.2*sh );
                lin += amb*vec3(0.40,0.60,0.80)*1.2;
                lin += bac*vec3(0.40,0.50,0.60);
                col *= lin;
                col += s*0.1*pow(fre,4.0)*vec3(7.0,5.0,3.0)*sh * pow( clamp(dot(light1,ref), 0.0, 1.0),16.0);
                col += s*0.1*pow(fre,4.0)*vec3(0.4,0.5,0.6)*smoothstep(0.0,0.6,ref.y);
                float fo = 1.0-exp(-0.001*t/SC );
                vec3 fco = 0.7*vec3(0.5,0.7,0.9) + 0.1*vec3(1.0,0.8,0.5)*pow( dot(light1,rd), 4.0 );
                col = mix( col, fco, fo );
                col += 0.3*vec3(1.0,0.8,0.4)*pow( dot(light1,rd), 8.0 )*(1.0-exp(-0.002*t/SC));
            }
            col = pow(col,vec3(0.4545));
            return col;
        }

        void main() {
            vec2 xy = -1.0 + 2.0*fragCoord;
            vec2 s = xy*vec2(iResolution.x/iResolution.y,1.0);
            
            // Phase 1: Mountains move backward while text is visible (0 to 0.20)
            // Phase 2: Mountains locked at text disappear point, camera moves down (0.20 to 1.0)
            
            float time;
            vec3 ro;
            vec3 ta;
            float cr;
            
            if (scrollProgress < 0.30) {
                // Phase 1: Normal backward movement (0-30%)
                time = 10.0 - scrollProgress * 7.7;
                ro = camPath( time );
                ta = camPath( time + 3.0 );
                ro.y = terrainL( ro.xz ) + 11.0*SC;
                ta.y = ro.y - 20.0*SC;
                cr = 0.2*cos(0.1*time);
            } else {
                // Phase 2: Lock camera completely at 30% - NO CHANGES
                time = 10.0 - (0.30 * 7.7);
                ro = camPath( time );
                ta = camPath( time + 3.0 );
                ro.y = terrainL( ro.xz ) + 11.0*SC;
                ta.y = ro.y - 20.0*SC;
                cr = 0.2*cos(0.1*time);
                // NO downward movement - camera stays locked
            }
            
            mat3 cam = setCamera( ro, ta, cr );
            vec3 rd = cam * normalize(vec3(s.xy,2.0));
            vec3 col = render( ro, rd );
            
            col *= 0.5 + 0.5*pow( (xy.x+1.0)*(xy.y+1.0)*(xy.x-1.0)*(xy.y-1.0), 0.1 );
            fragColor = vec4( col, 1.0 );
        }`;

        // Create noise textures with seeded random for consistency
        function createNoiseTexture(seed) {
            const size = 256;
            const data = new Uint8Array(size * size);
            
            // Seeded random number generator
            function seededRandom(s) {
                const x = Math.sin(s) * 10000;
                return x - Math.floor(x);
            }
            
            for (let i = 0; i < data.length; i++) {
                data[i] = Math.floor(seededRandom(i + seed) * 255);
            }
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.R8, size, size, 0, gl.RED, gl.UNSIGNED_BYTE, data);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
            return texture;
        }

        const program = gl.createProgram();
        const vs = gl.createShader(gl.VERTEX_SHADER);
        const fs = gl.createShader(gl.FRAGMENT_SHADER);

        gl.shaderSource(vs, vertexShader);
        gl.shaderSource(fs, fragmentShader);
        gl.compileShader(vs);
        gl.compileShader(fs);

        if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {
            console.error('Vertex shader error:', gl.getShaderInfoLog(vs));
        }
        if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {
            console.error('Fragment shader error:', gl.getShaderInfoLog(fs));
        }

        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program error:', gl.getProgramInfoLog(program));
        }

        gl.useProgram(program);

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]), gl.STATIC_DRAW);

        const positionLocation = gl.getAttribLocation(program, 'position');
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        const iResolutionLoc = gl.getUniformLocation(program, 'iResolution');
        const iTimeLoc = gl.getUniformLocation(program, 'iTime');
        const iMouseLoc = gl.getUniformLocation(program, 'iMouse');
        const iChannel0Loc = gl.getUniformLocation(program, 'iChannel0');
        const iChannel1Loc = gl.getUniformLocation(program, 'iChannel1');
        const iChannel2Loc = gl.getUniformLocation(program, 'iChannel2');
        const scrollProgressLoc = gl.getUniformLocation(program, 'scrollProgress');

        const noiseTexture0 = createNoiseTexture(1);
        const noiseTexture1 = createNoiseTexture(2);
        const noiseTexture2 = createNoiseTexture(3);

        let scrollProgress = 0;

        window.addEventListener('scroll', () => {
            const maxScroll = document.documentElement.scrollHeight - window.innerHeight;
            scrollProgress = window.scrollY / maxScroll;

            // Make text scale and fade as camera moves backward
            const heroContent = document.getElementById('heroContent');
            const heading = heroContent.querySelector('h1');
            const logos = heroContent.querySelector('.trusted-logos');
            
            // Scale down as camera moves back (text appears smaller/farther)
            const scale = 1 - (scrollProgress * 0.5);
            heading.style.transform = `scale(${scale})`;
            logos.style.transform = `scale(${scale})`;
            
            // Fade out as camera moves back
            const fadeStart = 0.05;
            const fadeEnd = 0.20;
            
            if (scrollProgress > fadeStart) {
                const fadeProgress = Math.min((scrollProgress - fadeStart) / (fadeEnd - fadeStart), 1);
                heroContent.style.opacity = 1 - fadeProgress;
                
                if (fadeProgress >= 1) {
                    heroContent.classList.add('fade-out');
                }
            } else {
                heroContent.classList.remove('fade-out');
                heroContent.style.opacity = 1;
            }

            // Lock mountains at 30% and move upward from there
            const contentSection = document.querySelector('.content-section');
            const canvas = document.getElementById('canvas');
            
            if (scrollProgress <= 0.30) {
                // 0-30%: Mountains moving backward (camera down), no upward movement yet
                canvas.style.transform = 'translateY(0)';
                contentSection.style.transform = 'translateY(0)';
                canvas.style.marginLeft = '0';
                canvas.style.marginRight = '0';
                canvas.style.width = '100%';
                canvas.style.borderRadius = '0';
            } else {
                // 30-70%: Mountains locked, move upward with container
                const moveProgress = (scrollProgress - 0.30) / 0.70;
                
                // Move both upward
                canvas.style.transform = `translateY(-${moveProgress * 100}vh)`;
                contentSection.style.transform = `translateY(-${moveProgress * 100}vh)`;
                
                // Add left/right padding only
                const sidePadding = moveProgress * 40;
                canvas.style.marginLeft = `${sidePadding}px`;
                canvas.style.marginRight = `${sidePadding}px`;
                canvas.style.width = `calc(100% - ${sidePadding * 2}px)`;
                canvas.style.borderRadius = `${moveProgress * 20}px`;
            }
        });

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        });

        function animate() {
            gl.uniform2f(iResolutionLoc, canvas.width, canvas.height);
            gl.uniform1f(iTimeLoc, 0.0);
            gl.uniform4f(iMouseLoc, 0, 0, 0, 0);
            gl.uniform1f(scrollProgressLoc, scrollProgress);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, noiseTexture0);
            gl.uniform1i(iChannel0Loc, 0);

            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, noiseTexture1);
            gl.uniform1i(iChannel1Loc, 1);

            gl.activeTexture(gl.TEXTURE2);
            gl.bindTexture(gl.TEXTURE_2D, noiseTexture2);
            gl.uniform1i(iChannel2Loc, 2);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            requestAnimationFrame(animate);
        }

        animate();
    </script>

    <script>
        // Cloud Shader Setup
        const cloudCanvas = document.getElementById('cloudCanvas');
        const glCloud = cloudCanvas.getContext('webgl2');

        cloudCanvas.width = window.innerWidth;
        cloudCanvas.height = window.innerHeight;

        const cloudVertexShader = `#version 300 es
        precision highp float;

        in vec2 position;
        out vec2 fragCoord;

        void main() {
            fragCoord = position * 0.5 + 0.5;
            gl_Position = vec4(position, 0.0, 1.0);
        }`;

        const cloudFragmentShader = `#version 300 es
        precision highp float;

        uniform vec2 iResolution;
        uniform float iTime;
        uniform sampler2D iChannel0;

        in vec2 fragCoord;
        out vec4 fragColor;

        float fTurbulence = 0.35;
        vec3 vNightColor   = vec3(.15, 0.3, 0.6);
        vec3 vHorizonColor = vec3(0.6, 0.3, 0.4);
        vec3 vDayColor     = vec3(0.7,0.8,1);
        vec3 vSunColor     = vec3(1.0,0.8,0.6);
        vec3 vSunRimColor  = vec3(1.0,0.66,0.33);

        float noise( in vec3 x ){
            vec3 p = floor(x);
            vec3 f = fract(x);
            f = f*f*f*(3.0-2.0*f);
            vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;
            vec4 rg = texture( iChannel0, (uv+ 0.5)/256.0, -100.0 );
            return (-1.0+2.0*mix( rg.g, rg.r, f.z ));
        }

        vec4 render( in vec3 ro, in vec3 rd ){
            float fSunSpeed = 0.35 * iTime;
            vec3 sundir = normalize( vec3(cos(fSunSpeed),sin(fSunSpeed),0.0) );
            float sun = clamp( dot(sundir,rd), 0.0, 1.0 );
            float fSunHeight = sundir.y;

            float fNightHeight = -0.8;
            float fDayHeight   = 0.3;
            float fHorizonLength = fDayHeight - fNightHeight;
            float fInverseHL = 1.0 / fHorizonLength;
            float fHalfHorizonLength = fHorizonLength / 2.0;
            float fInverseHHL = 1.0 / fHalfHorizonLength;
            float fMidPoint = fNightHeight + fHalfHorizonLength;

            float fNightContrib = clamp((fSunHeight - fMidPoint) * (-fInverseHHL), 0.0, 1.0);
            float fHorizonContrib = -clamp(abs((fSunHeight - fMidPoint) * (-fInverseHHL)), 0.0, 1.0) + 1.0;
            float fDayContrib = clamp((fSunHeight - fMidPoint) * ( fInverseHHL), 0.0, 1.0);

            vec3 vSkyColor = vec3(0.0);
            vSkyColor += mix(vec3(0.0),   vNightColor, fNightContrib);
            vSkyColor += mix(vec3(0.0), vHorizonColor, fHorizonContrib);
            vSkyColor += mix(vec3(0.0),     vDayColor, fDayContrib);

            vec3 col = vSkyColor;
            col -= clamp(rd.y, 0.0, 0.5);
            col += 0.4 * vSunRimColor * pow( sun,    4.0 );
            col += 1.0 * vSunColor    * pow( sun, 2000.0 );

            float fStarSpeed = -fSunSpeed * 0.5;
            float fStarContrib = clamp((fSunHeight - fDayHeight) * (-fInverseHL), 0.0, 1.0);
            vec3 vStarDir = rd * mat3( vec3(cos(fStarSpeed), -sin(fStarSpeed), 0.0),
                                       vec3(sin(fStarSpeed),  cos(fStarSpeed), 0.0),
                                       vec3(0.0,             0.0,            1.0));
            col += pow((texture(iChannel0, vStarDir.xy).r + texture(iChannel0, vStarDir.zy).r) * 0.5, 42.0) * fStarContrib * 40.0;

            return vec4( col, 1.0 );
        }

        mat3 setCamera( in vec3 ro, in vec3 ta, float cr ){
            vec3 cw = normalize(ta-ro);
            vec3 cp = vec3(sin(cr), cos(cr),0.0);
            vec3 cu = normalize( cross(cw,cp) );
            vec3 cv = normalize( cross(cu,cw) );
            return mat3( cu, cv, cw );
        }

        void main(){
            vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/ iResolution.y;
            vec2 m = vec2(0.25, 0.5);
            
            vec3 ro = 4.0*normalize(vec3(sin(6.28*m.x + 1.5), 0.4 * m.y, cos(6.28*m.x + 1.5)));
            vec3 ta = vec3(0.0, -1.0, 0.0);
            mat3 ca = setCamera( ro, ta, 0.0 );
            
            vec3 rd = ca * normalize( vec3(p.xy,1.5));
            fragColor = render( ro, rd );
        }`;

        const cloudProgram = glCloud.createProgram();
        const cvs = glCloud.createShader(glCloud.VERTEX_SHADER);
        const cfs = glCloud.createShader(glCloud.FRAGMENT_SHADER);

        glCloud.shaderSource(cvs, cloudVertexShader);
        glCloud.shaderSource(cfs, cloudFragmentShader);
        glCloud.compileShader(cvs);
        glCloud.compileShader(cfs);

        glCloud.attachShader(cloudProgram, cvs);
        glCloud.attachShader(cloudProgram, cfs);
        glCloud.linkProgram(cloudProgram);

        glCloud.useProgram(cloudProgram);

        const cloudPositionBuffer = glCloud.createBuffer();
        glCloud.bindBuffer(glCloud.ARRAY_BUFFER, cloudPositionBuffer);
        glCloud.bufferData(glCloud.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]), glCloud.STATIC_DRAW);

        const cloudPositionLocation = glCloud.getAttribLocation(cloudProgram, 'position');
        glCloud.enableVertexAttribArray(cloudPositionLocation);
        glCloud.vertexAttribPointer(cloudPositionLocation, 2, glCloud.FLOAT, false, 0, 0);

        const cloudIResolutionLoc = glCloud.getUniformLocation(cloudProgram, 'iResolution');
        const cloudITimeLoc = glCloud.getUniformLocation(cloudProgram, 'iTime');
        const cloudIChannel0Loc = glCloud.getUniformLocation(cloudProgram, 'iChannel0');

        const cloudNoiseTexture = createNoiseTexture();

        function createNoiseTexture() {
            const size = 256;
            const data = new Uint8Array(size * size);
            
            function seededRandom(s) {
                const x = Math.sin(s) * 10000;
                return x - Math.floor(x);
            }
            
            for (let i = 0; i < data.length; i++) {
                data[i] = Math.floor(seededRandom(i + 42) * 255);
            }
            const texture = glCloud.createTexture();
            glCloud.bindTexture(glCloud.TEXTURE_2D, texture);
            glCloud.texImage2D(glCloud.TEXTURE_2D, 0, glCloud.R8, size, size, 0, glCloud.RED, glCloud.UNSIGNED_BYTE, data);
            glCloud.texParameteri(glCloud.TEXTURE_2D, glCloud.TEXTURE_MIN_FILTER, glCloud.LINEAR);
            glCloud.texParameteri(glCloud.TEXTURE_2D, glCloud.TEXTURE_MAG_FILTER, glCloud.LINEAR);
            glCloud.texParameteri(glCloud.TEXTURE_2D, glCloud.TEXTURE_WRAP_S, glCloud.REPEAT);
            glCloud.texParameteri(glCloud.TEXTURE_2D, glCloud.TEXTURE_WRAP_T, glCloud.REPEAT);
            return texture;
        }

        let cloudScrollProgress = 0;
        let cloudStartTime = Date.now();

        window.addEventListener('scroll', () => {
            const maxScroll = document.documentElement.scrollHeight - window.innerHeight;
            const currentScroll = window.scrollY / maxScroll;
            
            // Show cloud canvas ONLY from 100% onwards (after Explore More section)
            const cloudCanvas = document.getElementById('cloudCanvas');
            if (currentScroll >= 1.0) {
                cloudCanvas.classList.add('show');
            } else {
                cloudCanvas.classList.remove('show');
            }
            
            // Calculate cloudScrollProgress for 100-200% range (day-to-night transition)
            if (currentScroll >= 1.0) {
                // Beyond 100%, map to 0-1 for day-to-night cycle
                cloudScrollProgress = Math.min((currentScroll - 1.0) / 1.0, 1.0);
            } else {
                cloudScrollProgress = 0;
            }
        });

        window.addEventListener('resize', () => {
            cloudCanvas.width = window.innerWidth;
            cloudCanvas.height = window.innerHeight;
            glCloud.viewport(0, 0, cloudCanvas.width, cloudCanvas.height);
        });

        function animateCloud() {
            glCloud.uniform2f(cloudIResolutionLoc, cloudCanvas.width, cloudCanvas.height);
            // Use scroll progress from 100-200% for day-to-night transition
            let cloudTime = 0;
            if (cloudScrollProgress > 0) {
                cloudTime = cloudScrollProgress * 10.0;
            }
            glCloud.uniform1f(cloudITimeLoc, cloudTime);
            
            glCloud.activeTexture(glCloud.TEXTURE0);
            glCloud.bindTexture(glCloud.TEXTURE_2D, cloudNoiseTexture);
            glCloud.uniform1i(cloudIChannel0Loc, 0);

            glCloud.drawArrays(glCloud.TRIANGLE_STRIP, 0, 4);
            requestAnimationFrame(animateCloud);
        }

        animateCloud();
    </script>
</body>
</html>
